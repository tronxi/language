load syntax .

mod SEMANTICS is
    pr SYNTAX .
    pr TYPE .
    
    sort System .

    op {_|_} : Program Memory -> System [ctor] .

    var M : Memory .
    var Q : Qid .
    var T : Type .
    var E : Expression .
    var P PBody PBodyElse : Program .
    var C : Condition .
    var A A' : Assig .
    var Array : Array .
    
    rl [coment] :
        { // PBody P | M}
        =>
        { P | M} .

    rl [print] :
        { print(Q); P | M}
        => 
        { P | M} .
    
    rl [assig] : 
        { (T = E); P | M}
        =>
        { P | assigInMemory(T = E, M) } .
    
    rl [assigArray] :
        { (T = [Array]); P | M}
        =>
        { P | assigInMemory(T = [Array], M, 0)} .

    crl [ifTrue] :
        { if(C){PBody} P | M }
        => 
        { PBody P | M } 
        if eval(C, M) .

    crl [ifFalse] :
        { if(C){PBody} P | M }
        => 
        { P | M } 
        if not eval(C, M) .

    crl [ifElseTrue] :
        { if(C){PBody}else{PBodyElse} P | M }
        => 
        { PBody P | M } 
        if eval(C, M) .

    crl [ifElseFalse] :
        { if(C){PBody}else{PBodyElse} P | M }
        => 
        { PBodyElse P | M } 
        if not eval(C, M) .

    crl [whileTrue] :
        { while(C){PBody} P | M }
        => 
        { PBody while(C){PBody} P | M } 
        if eval(C, M) .

    crl [whileFalse] :
        { while(C){PBody} P | M }
        => 
        { P | M } 
        if not eval(C, M) .

    rl [initalFor] :
        { for( (A); (C); (A'); ){PBody} P | M }
        =>
        { (A); forWithoutInitial((C); (A'); ){PBody} P | M } .

    crl [forTrue] :
        { forWithoutInitial((C); (A'); ){PBody} P | M }
        =>
        { PBody (A'); forWithoutInitial((C); (A'); ){PBody} P | M }
        if eval(C, M) .
 

    crl [forFalse] :
        { forWithoutInitial((C); (A'); ){PBody} P | M }
        =>
        { P | M }
        if not eval(C, M) .
    
endm